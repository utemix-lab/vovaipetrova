# Возможные маршруты исправления

**Дата:** 12 февраля 2026  
**Основа:** Диагноз из `2026-02-12_DIAGNOSIS.md`

---

## МАРШРУТ A: Продолжать строить фичи

### Описание

Продолжать разработку, фиксируя "течи" по мере обнаружения.
Не останавливаться на рефакторинг.

### Плюсы

- Быстрый прогресс по фичам
- Не ломаем работающий код
- Минимальные затраты времени

### Минусы

- Несогласованность растёт
- Каждая новая фича сложнее предыдущей
- IDE-агент всё больше "ищет источник истины"
- Рефлексия системы становится невозможной

### Когда выбирать

- Дедлайн
- Прототип, который будет переписан
- Нет ресурсов на рефакторинг

### Риски

- Технический долг накапливается экспоненциально
- В какой-то момент система станет неуправляемой

---

## МАРШРУТ B: Полный рефакторинг слоёв

### Описание

Остановиться и разделить `visitor.js` на изолированные слои:

```
render/src/
├── ontology/           # Чистые определения сущностей
│   ├── types.ts        # Типы узлов, рёбер, отношений
│   ├── invariants.ts   # Формальные инварианты
│   └── contracts.ts    # Контракты между слоями
├── state/              # Владение состоянием
│   ├── graph.ts        # Состояние графа
│   ├── highlight.ts    # Состояние подсветки
│   ├── navigation.ts   # Состояние навигации
│   └── ownership.ts    # Граф ответственности
├── logic/              # Правила и вычисления
│   ├── highlight.ts    # Правила подсветки
│   ├── neighbors.ts    # Вычисление соседей
│   └── templates.ts    # Логика шаблонов страниц
├── view/               # Представление
│   ├── dom/            # DOM-манипуляции
│   ├── three/          # Three.js
│   └── templates/      # HTML-шаблоны
└── infra/              # Инфраструктура
    ├── events.ts       # Event listeners
    └── animation.ts    # requestAnimationFrame
```

### Плюсы

- Полная изоляция слоёв
- Формальные контракты
- Система готова к рефлексии
- IDE-агент всегда знает, где искать

### Минусы

- Большие затраты времени (дни/недели)
- Риск сломать работающий код
- Требует полного понимания системы
- Может оказаться over-engineering для текущего этапа

### Когда выбирать

- Система будет жить долго
- Команда > 1 человека
- Есть время на рефакторинг

### Риски

- Застрять в рефакторинге
- Потерять momentum
- Переусложнить простую систему

---

## МАРШРУТ C: Минимальный формальный слой

### Описание

Создать документ `INVARIANTS.md` как спецификацию.
Не трогать код, но зафиксировать инварианты формально.
Потом постепенно переносить в код.

### Структура INVARIANTS.md

```markdown
# Формальные инварианты системы

## 1. Сущности
- Node: id, type, label, position
- Edge: id, source, target, type
- Highlight: context × node → intensity

## 2. Инварианты подсветки
- INV-H1: Выбранный узел всегда имеет intensity = 1.0
- INV-H2: При hover на виджет — узел и соседи intensity = 1.0
- INV-H3: При scope hover — все узлы scope intensity = 1.0

## 3. Владение состоянием
- currentStep: владелец = selectNode()
- highlightedNodes: владелец = applyHighlightSet()

## 4. Контракты
- highlight(context, node) → intensity ∈ [0, 1]
- neighbors(nodeId) → Set<nodeId>
```

### Плюсы

- Минимальные затраты времени
- Не ломаем код
- Создаём "точку истины" для IDE-агента
- Можно постепенно формализовать

### Минусы

- Документация может разойтись с кодом
- Нет автоматической проверки
- Требует дисциплины

### Когда выбирать

- Нужен компромисс
- Нет времени на полный рефакторинг
- Хотим зафиксировать понимание

### Риски

- Документация станет мёртвой
- Инварианты не будут соблюдаться

---

## МАРШРУТ D: Типизация как инварианты

### Описание

Перевести критические части на TypeScript.
Типы = формальные инварианты, проверяемые компилятором.

### Пример

```typescript
// ontology/types.ts
type NodeType = "root" | "hub" | "character" | "domain" | "workbench" | "collab";
type EdgeType = "structural" | "relates";

interface Node {
  id: string;
  type: NodeType;
  label: string;
}

interface HighlightContext {
  selected: string | null;
  hovered: string | null;
  scope: Set<string>;
}

type Intensity = 0 | 0.15 | 0.5 | 1.0;

function computeHighlight(ctx: HighlightContext, nodeId: string): Intensity {
  // Формальная логика
}
```

### Плюсы

- Инварианты проверяются компилятором
- IDE подсказывает ошибки
- Документация встроена в код
- Рефакторинг безопаснее

### Минусы

- Требует миграции на TypeScript
- Не все инварианты выразимы в типах
- Увеличивает сложность сборки

### Когда выбирать

- Система будет расти
- Нужна надёжность
- Команда знает TypeScript

### Риски

- Миграция может затянуться
- Типы могут стать слишком сложными

---

## МАРШРУТ E: Граф ответственности как артефакт

### Описание

Создать явный граф ответственности.
Не менять код, но визуализировать потоки данных.

### Формат

```
docs/OWNERSHIP_GRAPH.md

## Состояние: currentStep

Владелец: selectNode()
Читатели:
  - updateStoryPanel()
  - applyHighlightSet()
  - getRelatedNodeIdsByType()
  - ...

Инварианты:
  - Всегда указывает на существующий узел или null
  - Изменяется только через selectNode()

## Состояние: highlightedNodes

Владелец: applyHighlightSet()
Модификаторы:
  - handleWidgetHover()
  - handleWidgetLeave()
  - clearHighlight()
Читатели:
  - applyNodeMaterial()
  - updateLinkOpacities()

Инварианты:
  - Содержит только существующие nodeId
  - Очищается при смене currentStep
```

### Плюсы

- Визуализирует скрытые зависимости
- Помогает IDE-агенту
- Не требует изменения кода

### Минусы

- Ручное поддержание
- Может устареть

### Когда выбирать

- Нужно понять систему
- Подготовка к рефакторингу

---

## МАРШРУТ F: Гибридный подход

### Описание

Комбинация маршрутов C + E + постепенная типизация.

1. **Сейчас:** Создать `INVARIANTS.md` и `OWNERSHIP_GRAPH.md`
2. **Постепенно:** Переносить инварианты в TypeScript
3. **При добавлении фич:** Проверять соответствие документации

### Плюсы

- Баланс между скоростью и качеством
- Постепенное улучшение
- Не блокирует разработку

### Минусы

- Требует дисциплины
- Риск забросить документацию

### Когда выбирать

- Нужен практичный компромисс
- Один разработчик + IDE-агент

---

## МАРШРУТ G: Формализация вычислительной модели (ВЫБРАН)

### Описание

Не разделять файлы. Не переписывать всё. Не делать документацию.

**Сделать только одно:** выделить чистую вычислительную модель.

```javascript
// ontology/highlightModel.js
export function computeHighlight(context, graph) {
  // Чистая функция без side effects
  return {
    nodeIntensities: Map<NodeId, Float>,
    edgeIntensities: Map<EdgeId, Float>
  };
}
```

Без DOM. Без Three.js. Без React. Без side effects.

### Философское обоснование

Проблема не в структуре файлов. Проблема в **степени формализации онтологии**.

Сейчас `highlight` — это одновременно:
- событие
- состояние
- эффект
- правило
- визуализация

Пока это не отделено — рефлексии не будет.

### Ключевой сдвиг

**Было:**
```
highlightedNodes — источник истины
```

**Станет:**
```
highlightedNodes — производная от вычислительной модели
```

**Было:**
```
handleHover →
  modify highlightedNodes →
    applyNodeMaterial →
      updateLinkOpacities
```

**Станет:**
```
newHighlightState = computeHighlight(graphState)
renderHighlight(newHighlightState)
```

Один вход. Один выход. Без мутаций из 5 мест.

### Почему это важнее разделения visitor.js

LLM + RAG + GraphRAG смогут анализировать:
- онтологию
- состояния
- отношения

Но не смогут анализировать:
- DOM-манипуляции
- размазанные side effects
- мутабельный Set

### Что изменится

После выделения чистой модели:
- `visitor.js` может оставаться 4500 строк
- DOM может быть messy
- Three.js может быть messy

Но появится **формальная точка причинности**.

А это уже шаг к рефлексии.

### Архитектурный принцип

Не "разделение по папкам".

А: **Чистые функции для всего, что выражает онтологию.**

### Минимальный практический шаг

1. Создать `ontology/highlightModel.js`
2. Реализовать `computeHighlight(context, graph)`
3. Сделать `visitor.js` полностью зависимым от результата этой функции
4. Никакой другой код не имеет права менять `highlightedNodes`

### После этого можно думать о

- ownership graph
- разделении слоёв
- инвариантах как контракте
- типизации
- OWL-экспорте

### Плюсы

- Минимальное вмешательство в код
- Формальная точка причинности
- Готовность к рефлексии
- Не цементирует полу-интуитивную модель

### Минусы

- Требует понимания всех текущих путей подсветки
- Может потребовать итераций для стабилизации API

### Когда выбирать

- Цель — мета-архитектура, а не продукт
- Система должна быть рефлексивной
- Один разработчик + IDE-агент

---

## СРАВНИТЕЛЬНАЯ ТАБЛИЦА

| Маршрут | Время | Риск | Результат | Для кого |
|---------|-------|------|-----------|----------|
| A: Продолжать | Минимум | Высокий | Технический долг | Прототип |
| B: Полный рефакторинг | Максимум | Средний | Чистая архитектура | Команда |
| C: INVARIANTS.md | Малое | Низкий | Точка истины | Один разработчик |
| D: TypeScript | Среднее | Средний | Проверяемые инварианты | Долгосрочный проект |
| E: OWNERSHIP_GRAPH | Малое | Низкий | Понимание системы | Подготовка |
| F: Гибридный | Малое→Среднее | Низкий | Постепенное улучшение | Практичный выбор |
| **G: Вычислительная модель** | Малое | Низкий | Формальная причинность | **ВЫБРАН** |

---

## РЕКОМЕНДАЦИЯ (УСТАРЕЛА)

~~Для текущего состояния системы (один разработчик + IDE-агент, работающий прототип, нарастающая несогласованность):~~

~~**Рекомендуется: Маршрут F (Гибридный)**~~

**ВЫБРАН: Маршрут G (Формализация вычислительной модели)**

См. `DECISIONS.md` для обоснования.

---

## ИСТОРИЧЕСКАЯ РЕКОМЕНДАЦИЯ (до выбора маршрута G)

1. Создать `INVARIANTS.md` — 1-2 часа
2. Создать `OWNERSHIP_GRAPH.md` — 1-2 часа
3. Продолжать разработку с проверкой соответствия
4. Постепенно типизировать критические части

---

*Маршруты зафиксированы. Следующий шаг: выбрать маршрут и зафиксировать решение в `DECISIONS.md`.*

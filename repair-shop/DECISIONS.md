# Принятые решения

**Дата создания:** 12 февраля 2026

---

## Решение #1: Выбор маршрута

**Дата:** 12 февраля 2026  
**Маршрут:** G — Формализация вычислительной модели  
**Статус:** ПРИНЯТО

### Контекст

IDE-агент предложил маршруты A-F:
- A: Продолжать строить фичи
- B: Полный рефакторинг слоёв
- C: Документ INVARIANTS.md
- D: Типизация как инварианты
- E: Граф ответственности как артефакт
- F: Гибридный подход

### Почему не A, B, C, D, E, F

**A (Продолжать):** Путь энтропии. Работает для продукта, не для мета-архитектуры.

**B (Полный рефакторинг):** Радикально и правильно в долгую. Но риск зацементировать полу-интуитивную модель, которая ещё не стабилизировалась.

**C (INVARIANTS.md):** Документ вне кода = снова расщепление истины. Уже видно на примере HIGHLIGHT_SYSTEM.md.

**D (TypeScript):** Полезно, но это структурный рефакторинг, а не формализация онтологии.

**E (OWNERSHIP_GRAPH):** Полезно для понимания, но не решает корневую проблему.

**F (Гибридный):** Компромисс, но не затрагивает главное.

### Почему G

**Главное:** Проблема не в структуре файлов. Проблема в **степени формализации онтологии**.

Сейчас `highlight` — это одновременно:
- событие
- состояние
- эффект
- правило
- визуализация

Пока это не отделено — рефлексии не будет.

### Ключевой сдвиг

```
БЫЛО:  highlightedNodes — источник истины
БУДЕТ: highlightedNodes — производная от вычислительной модели
```

```
БЫЛО:
handleHover →
  modify highlightedNodes →
    applyNodeMaterial →
      updateLinkOpacities

БУДЕТ:
newHighlightState = computeHighlight(graphState)
renderHighlight(newHighlightState)
```

Один вход. Один выход. Без мутаций из 5 мест.

### Архитектурный принцип

Не "разделение по папкам".

А: **Чистые функции для всего, что выражает онтологию.**

### Философское обоснование

Сущность определяется:
- инвариантами
- допустимыми отношениями
- **вычислимым поведением**

Если поведение размазано — это не сущность. Это procedural artifact.

LLM + RAG + GraphRAG смогут анализировать:
- онтологию
- состояния
- отношения

Но не смогут анализировать:
- DOM-манипуляции
- размазанные side effects
- мутабельный Set

### План реализации

1. Создать `ontology/highlightModel.js`
2. Реализовать `computeHighlight(context, graph)`
3. Сделать `visitor.js` полностью зависимым от результата этой функции
4. Никакой другой код не имеет права менять `highlightedNodes`

### После этого можно думать о

- ownership graph
- разделении слоёв
- инвариантах как контракте
- типизации
- OWL-экспорте

### Ожидаемый результат

После выделения чистой модели:
- `visitor.js` может оставаться 4500 строк
- DOM может быть messy
- Three.js может быть messy

Но появится **формальная точка причинности**.

А это уже шаг к рефлексии.

---

*Следующий шаг: создать `ontology/highlightModel.js` и реализовать `computeHighlight()`.*

# Архитектурный диагноз

**Дата:** 12 февраля 2026  
**Состояние системы:** Работающий прототип с нарастающей несогласованностью  
**Главный файл:** `render/src/scenes/visitor.js` (~4500 строк)

---

## 1. КОРНЕВАЯ ПРОБЛЕМА

### Формулировка

**Ограничение когнитивной ёмкости при отсутствии формального слоя инвариантов.**

Мозг (человека и IDE-агента) не видит весь граф зависимостей.
Инварианты существуют только в голове разработчика.
При каждом изменении приходится "искать источник истины".

### Симптомы

1. IDE-агент (Cascade) каждый раз заново ищет, где определён параметр
2. Изменение в одном месте ломает поведение в другом
3. Документация расходится с кодом
4. Новые фичи добавляют параметры вместо использования существующих отношений

---

## 2. СМЕШЕНИЕ СЛОЁВ

### Текущее состояние

В `visitor.js` смешаны 5 архитектурных слоёв:

```
┌─────────────────────────────────────────────────────────────────┐
│                         visitor.js                               │
├─────────────────────────────────────────────────────────────────┤
│  ОНТОЛОГИЯ                                                       │
│  - nodesById, edgesById (загружаются из universe.json)          │
│  - типы узлов (character, domain, hub, root...)                 │
│  - отношения (relates, structural)                              │
├─────────────────────────────────────────────────────────────────┤
│  СОСТОЯНИЕ                                                       │
│  - currentStep (текущий выбранный узел)                         │
│  - highlightedNodes (Set подсвеченных узлов)                    │
│  - expandedState (состояние Narrative Screen)                   │
│  - typeHighlightMode (режим подсветки типа)                     │
│  - miniCubeGroup, miniCubeScene... (состояние 3D)               │
├─────────────────────────────────────────────────────────────────┤
│  ЛОГИКА (правила)                                                │
│  - getRelatedNodeIdsByType() — вычисление соседей               │
│  - highlight rules в VISUAL_CONFIG                              │
│  - правила навигации Narrative Screen                           │
├─────────────────────────────────────────────────────────────────┤
│  ПРЕДСТАВЛЕНИЕ                                                   │
│  - DOM-манипуляции (innerHTML, classList)                       │
│  - HTML-шаблоны (updateStoryWithHub, updateStoryWithRoot...)    │
│  - CSS-классы                                                    │
├─────────────────────────────────────────────────────────────────┤
│  ИНФРАСТРУКТУРА                                                  │
│  - Three.js (сцена, камера, рендерер)                           │
│  - Event listeners (mouseenter, mouseleave, click)              │
│  - requestAnimationFrame                                         │
└─────────────────────────────────────────────────────────────────┘
```

### Проблема

Изменение в любом слое требует понимания всех остальных.
Нет изоляции. Нет контрактов между слоями.

---

## 3. ОТСУТСТВИЕ СЛОЯ ИНВАРИАНТОВ

### Что такое инвариант

Инвариант — это правило, которое **всегда истинно** для системы.
Не комментарий. Не документация. Часть кода.

### Текущее состояние

| Инвариант | Где определён | Формализован? |
|-----------|---------------|---------------|
| "Узел не может быть подсвечен, если он не в активном контексте" | Нигде | ❌ |
| "Подсветка соседей — функция графа, а не UI" | В голове | ❌ |
| "Отношение симметрично или направлено" | universe.json (неявно) | ❌ |
| "Выбранный узел всегда имеет полную яркость" | VISUAL_CONFIG.highlight.rules | ⚠️ Частично |
| "Scope hover подсвечивает все связанные узлы" | VISUAL_CONFIG.highlight.rules | ⚠️ Частично |

### Пример: VISUAL_CONFIG.highlight.rules

```javascript
rules: {
  selected: {
    node: "full",
    neighborLinks: "half"
  },
  hover: {
    node: "full",
    neighborLinks: "full"
  },
  scope: {
    nodes: "full",
    links: "full"
  }
}
```

Это **конфиг**, а не **контракт**.
- Нет проверки соблюдения
- Нет типизации
- Нет связи с реализацией

Реализация размазана по функциям:
- `applyHighlightSet()`
- `handleWidgetHover()`
- `handleWidgetLeave()`
- `applyNodeMaterial()`
- `updateLinkOpacities()`

---

## 4. НЕЯВНЫЕ СУЩНОСТИ

### Проблема

В онтологии сущностями являются не только узлы.
Но система не определяет их формально.

### Таблица неявных сущностей

| Сущность | Онтологический статус | Где определена | Проблема |
|----------|----------------------|----------------|----------|
| **Node** | Явная сущность | universe.json | ✅ OK |
| **Edge** | Явная сущность | universe.json | ✅ OK |
| **Highlight** | ❓ | Размазано | UI-эффект? Состояние? Отношение? |
| **Scope** | ❓ | Неявно | Контекст? Отношение? |
| **NarrativeSlide** | ❓ | Локальная переменная | Состояние? Событие? |
| **WidgetGroup** | ❓ | Только в HTML | Контейнер? Отношение? |
| **PageTemplate** | ❓ | Функции updateStoryWith* | Тип? Правило? |
| **TypeHighlightMode** | ❓ | Булева переменная | Режим? Состояние? |

### Пример: Highlight

**Вопрос:** Подсветка — это что?

| Интерпретация | Следствие |
|---------------|-----------|
| UI-эффект | Должна быть в слое представления |
| Состояние | Должна иметь владельца |
| Отношение | Должна быть в онтологии |
| Событие | Должна иметь жизненный цикл |

**Текущая реализация:** Всё сразу. Смешано.

---

## 5. ОТСУТСТВИЕ ГРАФА ОТВЕТСТВЕННОСТИ

### Что это

Граф ответственности показывает:
- Кто **владеет** состоянием
- Кто **производит** вычисление
- Кто **потребляет** результат

### Текущее состояние

| Состояние | Кто устанавливает | Кто читает | Владелец |
|-----------|-------------------|------------|----------|
| `currentStep` | `selectNode()` | 20+ функций | ❓ Неявно |
| `highlightedNodes` | 5+ функций | 10+ функций | ❓ Неявно |
| `miniCubeGroup` | `initMiniShape()` | `animateMiniCube()`, `destroyMiniCube()` | ❓ Глобальная |
| `expandedState` | `bindNarrativeScreen()` | `bindNarrativeScreen()` | ⚠️ Локально |

### Проблема

Нет формального владения.
IDE-агент "ищет источник истины" потому что его нет как объекта.

---

## 6. НАРУШЕНИЕ МИНИМИЗАЦИИ ВЫРАЗИТЕЛЬНОЙ МОЩНОСТИ

### Принцип

Каждый новый параметр:
- Увеличивает энтропию
- Усложняет рефлексию
- Усложняет GraphRAG

Перед добавлением параметра нужно проверить:
**Можно ли выразить это через существующие отношения?**

### Примеры нарушений

| Новый параметр | Можно ли выразить иначе? |
|----------------|--------------------------|
| `isShapePage` | Да: `slideIndex === 0` |
| `typeHighlightMode` | Возможно: через scope |
| `expandedState` | Возможно: через CSS-класс |

### Следствие

Каждая новая фича добавляет параметры.
Система становится менее прозрачной.

---

## 7. КОНКРЕТНЫЕ ПРИМЕРЫ "ТЕЧИ"

### 7.1. Подсветка при hover на виджет

**Поток данных:**

```
mouseenter на виджет
    ↓
bindHighlightWidgets() — вешает обработчик
    ↓
handleWidgetHover() — вычисляет соседей через getRelatedNodeIdsByType()
    ↓
applyHighlightSet() — модифицирует highlightedNodes (Set)
    ↓
applyNodeMaterial() — читает highlightedNodes, меняет Three.js материал
    ↓
updateLinkOpacities() — читает highlightedNodes, меняет opacity линий
```

**Где инвариант?**
Нигде формально. В документации `HIGHLIGHT_SYSTEM.md`.

**Где источник истины?**
`highlightedNodes` — но это Set, который модифицируется из 5+ мест.

### 7.2. Навигация Narrative Screen

**Поток данных:**

```
click на точку навигации
    ↓
bindNarrativeScreen() — обработчик
    ↓
Локальные переменные: currentIndex, expanded
    ↓
DOM-манипуляции: classList, style.transform
    ↓
Условная логика: isShapePage, canExpand
```

**Проблема:**
Состояние навигации существует только внутри closure.
Нет способа узнать текущий слайд извне.

### 7.3. Шаблоны страниц

**Текущее состояние:**

```javascript
function updateStoryWithHub(panel, node) { ... }
function updateStoryWithRoot(panel, node) { ... }
function updateStoryWithPotential(panel, node) { ... }
function updateStoryWithDomainFocus(panel, node) { ... }
function updateStoryWithWorkbench(panel, node) { ... }
function updateStoryWithCollab(panel, node) { ... }
```

**Проблема:**
- Дублирование логики (Narrative Screen, виджеты, bindings)
- Нет общего контракта "что такое страница"
- Добавление нового типа требует копирования кода

---

## 8. ЧТО ГРАФ КОДА НЕ ПОКАЖЕТ

### 8.1. Семантическая плотность

Граф покажет: `A → B → C`

Не покажет:
- Избыточность
- Дублирование логики
- Альтернативные способы достижения результата
- Неявные инварианты

### 8.2. Нарушение уровней абстракции

Примеры в текущем коде:
- UI-функция (`updateStoryWithHub`) знает про Three.js (`initMiniShape`)
- Логика подсветки (`applyHighlightSet`) манипулирует DOM
- Онтология (`VISUAL_CONFIG`) содержит UI-параметры

Граф зависимостей это покажет.
Но не покажет, что это **архитектурная ошибка**.

### 8.3. Размытые границы ответственности

Граф не покажет:
- Кто отвечает за истину
- Где источник состояния
- Где каноническое определение

---

## 9. МЕТРИКИ ТЕКУЩЕГО СОСТОЯНИЯ

### Количественные

| Метрика | Значение |
|---------|----------|
| Строк в visitor.js | ~4500 |
| Глобальных переменных | 15+ |
| Функций | 100+ |
| Слоёв в одном файле | 5 |
| Формализованных инвариантов | 0 |

### Качественные

| Аспект | Оценка |
|--------|--------|
| Изоляция слоёв | ❌ Отсутствует |
| Единый источник истины | ⚠️ Частично (universe.json) |
| Формальные инварианты | ❌ Отсутствуют |
| Граф ответственности | ❌ Отсутствует |
| Минимизация параметров | ⚠️ Нарушается |

---

## 10. КОРНЕВЫЕ ВОПРОСЫ

Эти вопросы нужно задавать при любом маршруте исправления:

1. **Где источник истины для X?**
   - Если ответ "в нескольких местах" — проблема

2. **Кто владеет состоянием Y?**
   - Если ответ "несколько функций модифицируют" — проблема

3. **Какой инвариант гарантирует Z?**
   - Если ответ "это в комментарии" — проблема

4. **Можно ли выразить новый параметр через существующие отношения?**
   - Если ответ "нет, нужен новый флаг" — проверить дважды

5. **К какому слою относится эта функция?**
   - Если ответ "к нескольким" — проблема

---

## 11. ДИАГНОЗ: РЕЗЮМЕ

### Главная болезнь

**Отсутствие формального слоя инвариантов** при наличии работающей системы.

### Симптомы

1. Смешение 5 архитектурных слоёв в одном файле
2. Неявные сущности (Highlight, Scope, PageTemplate)
3. Отсутствие графа ответственности
4. Нарушение минимизации выразительной мощности
5. IDE-агент каждый раз "ищет источник истины"

### Прогноз без лечения

Несогласованность будет расти как снежный ком.
Каждая новая фича будет добавлять энтропию.
Рефлексия системы станет невозможной.

### Прогноз с лечением

Зависит от выбранного маршрута.
См. `ROUTES.md`.

---

## 12. ПРИЛОЖЕНИЕ: КОНКРЕТНЫЕ ФАЙЛЫ И СТРОКИ

### visitor.js — ключевые участки

| Строки | Содержимое | Слой |
|--------|------------|------|
| 1-100 | Импорты, глобальные переменные | Инфраструктура |
| 100-300 | VISUAL_CONFIG | Онтология + Логика |
| 300-500 | Инициализация Three.js | Инфраструктура |
| 500-1500 | Функции графа | Логика + Представление |
| 1500-2500 | Шаблоны страниц | Представление + Логика |
| 2500-3500 | Подсветка, виджеты | Состояние + Логика + Представление |
| 3500-4500 | 3D фигуры, анимация | Инфраструктура + Состояние |

### universe.json — единственный чистый источник

- Узлы: `nodes[]`
- Рёбра: `edges[]`
- Это **онтология** в чистом виде
- Но она не содержит инвариантов

### VISUAL_CONFIG — смешанный конфиг

- `nodeTypes` — онтология
- `colors` — представление
- `highlight.rules` — логика (но не формализованная)
- `labels` — представление

---

*Диагноз зафиксирован. Следующий шаг: определить возможные маршруты исправления.*

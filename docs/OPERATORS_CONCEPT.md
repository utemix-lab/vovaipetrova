# Epistemic Operators — Концепция Track 3

**Дата:** 15 февраля 2026
**Track:** 3 — OPERATORS (Epistemic)
**Статус:** Концептуализация

> **Статус системы:** [`STATUS.md`](../STATUS.md) — главная точка входа.

---

## Проблема

Графоцентричная система создаёт ловушку:

```
Граф = единственный источник истины
    ↓
Всё, что хочешь мыслить, должно стать узлом
    ↓
Внешний мир огромен → граф становится неподъёмным
```

**Противоречие:** Хотим мыслить внешний мир, не включая его целиком в граф.

---

## Решение: Три механизма

```
┌─────────────────────────────────────────────────────────┐
│                      GRAPH (Track 1)                    │
│              Узлы, связи, онтология                     │
│              Маленький, стабильный                      │
└─────────────────────────────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┐
          ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   OPERATORS     │ │   PROJECTIONS   │ │   CATALOGS      │
│   (Track 3)     │ │   (Track 4)     │ │   (World data)  │
│                 │ │                 │ │                 │
│ Как запрашивать │ │ Как отображать  │ │ Внешние данные  │
│ внешние данные  │ │ граф            │ │                 │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

### Разделение понятий

| Механизм | Track | Назначение | Пример |
|----------|-------|------------|--------|
| **Graph** | 1 | Что существует (онтология) | Узел "Синтезатор" |
| **Catalogs** | — | На что указываем (данные) | `vst.json` с 1000 плагинов |
| **Operators** | 3 | Как узнаём (эпистемология) | `PROJECT(Музыкант, vst)` |
| **Projections** | 4 | Как отображаем (визуализация) | VisitorProjection, OWLProjection |

---

## Каталоги (Catalogs)

Каталоги — это **внешние данные**, живущие вне графа.

### Принцип

- Каталог = JSON-файл с записями
- Запись ≠ узел графа
- Каталог связан с графом через `catalogRefs` в узлах

### Пример

```json
// worlds/vovaipetrova/catalogs/vst.json
{
  "id": "vst",
  "schema": {
    "name": "string",
    "manufacturer": "string",
    "year": "number",
    "genre": "string[]",
    "tags": "string[]"
  },
  "entries": [
    { "id": "serum", "name": "Serum", "manufacturer": "Xfer", "year": 2014, "genre": ["edm", "bass"], "tags": ["wavetable", "synth"] },
    { "id": "massive", "name": "Massive X", "manufacturer": "NI", "year": 2019, "genre": ["techno", "dnb"], "tags": ["wavetable", "synth"] },
    { "id": "vital", "name": "Vital", "manufacturer": "Matt Tytel", "year": 2020, "genre": ["any"], "tags": ["wavetable", "free"] }
  ]
}
```

### Связь с графом

```json
// В seed.json мира
{
  "id": "tool-synth",
  "type": "artifact",
  "label": "Синтезатор",
  "catalogRefs": {
    "vst": ["serum", "massive", "vital"]
  }
}
```

**Результат:** 1000 VST в каталоге, но в графе только 1 узел "Синтезатор".

---

## Операторы (Operators)

Операторы — это **способы работы со знанием**, а не само знание.

### Ключевые свойства

1. **Не меняют граф** (инвариантность)
2. **Композируемы** (можно строить цепочки)
3. **Зависят от контекста** (разные персонажи → разные результаты)

### Базовые операторы

| Оператор | Назначение | Сигнатура |
|----------|------------|-----------|
| `PROJECT` | Спроецировать каталог через узел | `PROJECT(nodeId, catalogName) → entries[]` |
| `FILTER` | Отфильтровать записи | `FILTER(entries, predicate) → entries[]` |
| `EXPAND` | Развернуть связи узла | `EXPAND(nodeId, depth) → nodeIds[]` |
| `INTERSECT` | Пересечение результатов | `INTERSECT(entries1, entries2) → entries[]` |

### Пример работы

```javascript
// Запрос: "Какие VST подходят для Музыканта?"
const result = PROJECT("character-musician", "vst");
// → [serum, vital] (только те, что связаны через catalogRefs или теги)

// Цепочка операторов
const filtered = FILTER(
  PROJECT("character-musician", "vst"),
  { year: { $gt: 2018 } }
);
// → [vital] (только после 2018)
```

### Эпистемическая множественность

Один каталог, разные персонажи → разные результаты:

```javascript
PROJECT("character-musician", "vst")     // → [serum, massive, vital]
PROJECT("character-developer", "vst")    // → [] (разработчику VST не нужны)
PROJECT("character-sound-engineer", "vst") // → [massive, vital]
```

---

## Pointer-tags как ключи доступа

Pointer-tags становятся **языком запросов**, а не атрибутами узлов.

### Было (проблема)

```
cap:lipsync на узле = "у узла есть свойство lipsync"
```

Это засоряет граф атрибутами.

### Стало (решение)

```
cap:lipsync на узле = "примени оператор, который найдёт записи с тегом lipsync"
```

Тег — это **ключ доступа к каталогу**, а не свойство узла.

### Пример

```json
// Узел в графе
{
  "id": "character-animator",
  "type": "character",
  "tags": ["cap:lipsync", "cap:motion-capture"]
}

// Каталог AI-моделей
{
  "entries": [
    { "id": "wav2lip", "tags": ["lipsync", "audio2video"] },
    { "id": "sadtalker", "tags": ["lipsync", "portrait"] }
  ]
}
```

```javascript
// Оператор использует теги как фильтр
PROJECT("character-animator", "ai-models")
// → [wav2lip, sadtalker] (потому что у персонажа есть cap:lipsync)
```

---

## Разделение ответственности

### Платформа (Engine)

| Компонент | Ответственность |
|-----------|-----------------|
| `WorldInterface.getCatalogs()` | Контракт: мир может предоставлять каталоги |
| `OperatorEngine` | Базовые операторы (PROJECT, FILTER, EXPAND) |
| `CatalogRegistry` | Загрузка и индексация каталогов |

### Мир (World)

| Компонент | Ответственность |
|-----------|-----------------|
| `catalogs/*.json` | Конкретные каталоги (vst, ai-models, tools) |
| `catalog-schema.json` | Схема атрибутов каталога |
| `operator-rules.json` | Правила интерпретации тегов |
| `catalogRefs` в узлах | Явные ссылки на записи каталога |

---

## Отличие от Projections (Track 4)

| Аспект | Operators (Track 3) | Projections (Track 4) |
|--------|---------------------|----------------------|
| **Вопрос** | Как узнать? | Как показать? |
| **Вход** | Граф + Каталоги | Граф |
| **Выход** | Записи из каталогов | Визуальное представление |
| **Примеры** | PROJECT, FILTER | VisitorProjection, OWLProjection |
| **Сохраняется?** | Нет (вычисляется на лету) | Нет (рендерится на лету) |

---

## Архитектурные инварианты

1. **Операторы не создают узлы** — результат оператора ≠ новый узел графа
2. **Каталоги не влияют на граф** — изменение каталога не меняет структуру графа
3. **Теги — ключи, не атрибуты** — `cap:X` означает "найди записи с тегом X", а не "у узла есть свойство X"
4. **Граф остаётся маленьким** — только мета-сущности (персонажи, домены, инструменты)

---

## План реализации

| Этап | Описание | Статус |
|------|----------|--------|
| T3.0a | Контракт `getCatalogs()` в WorldInterface | Ожидает |
| T3.0b | `CatalogRegistry` — загрузка каталогов | Ожидает |
| T3.0c | `OperatorEngine` — базовые операторы | Ожидает |
| T3.0d | Первый каталог в мире (vst или tools) | Ожидает |
| T3.0e | Интеграция с pointer-tags | Ожидает |
| T3.0f | UI для отображения результатов операторов | Ожидает |

---

## Итог

```
Граф — онтология (что есть)
Каталоги — референты (на что указываем)
Операторы — эпистемология (как узнаём)
Проекции — визуализация (как показываем)
```

**Океан знаний не становится онтологией. Он становится набором данных, на которые указывает онтология.**

---

*Связанные документы:*
- `docs/ARCHITECTURE_TRACKS.md` — спецификация треков
- `engine/WORLD_CONTRACT.md` — контракт Engine ↔ World
- `STATUS.md` — текущий статус системы

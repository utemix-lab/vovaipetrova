# ARCHITECTURE TRACKS — v3.0

**Дата:** 13 февраля 2026

> **Статус системы:** [`STATUS.md`](../STATUS.md) — главная точка входа.

---

## Контекст

Разработка, описание и анализ системы организованы по **трекам (Tracks)** — независимым плоскостям рассмотрения одной и той же системы.

**Треки не являются частями системы**, а представляют собой **ракурсы её понимания** и работы с ней.

Каждый трек отвечает на свой вопрос и обеспечивает дисциплину мышления, чтобы не смешивать уровни.

---

## Общие принципы

```
Система едина — есть один мир, один движок, один набор операторов, один UI.
```

- **Tracks = ракурсы / методология**, а не модули
- Ни один трек не определяет другой
- Связи между треками возможны только через **явно определённые интерфейсы**
- Цель — многослойная читаемость и управление проектом без смешения уровней

---

## TRACK 0 — Meta / Product / Reflexive Layer

**Вопрос:** Что такое Платформа как самостоятельный продукт?

### Назначение

- Позиционирование платформы
- Презентация, демонстрация, интерактивная «Кабина платформы»
- Само-описание системы и режим разговора системы о себе

### Примеры

- HF Spaces демо-интерфейс
- Интерфейс с LLM, объясняющей устройство платформы
- Режим Platform-only без привязки к Миру

### Ограничения

- Не изменяет Ontology
- Не изменяет Schema
- Не создаёт сущности Мира
- Может использовать Operators

**Важно:** Track 0 — надстройка над системой, а не часть онтологии или движка.

---

## TRACK 1 — Ontology (Universe Layer)

**Вопрос:** Что существует в Мире?

### Содержит

- Типы узлов (Character, Domain, Workbench, Collab, System Nodes)
- Типы связей (operates_in, has, focuses_on, participates_in, intersects)
- Graph Invariance Principle
- Distinction Projection Layer vs Graph

### Не содержит

- UI-режимы
- LLM
- Operators
- Платформенную логику

### Принцип

```
Graph = invariant.
Онтология не меняется инструментами.
Она описывает существующее.
```

### Backlog Track 1

| Задача | Описание | Статус |
|--------|----------|--------|
| **Унификация источников Практик** | Сейчас практики определены в двух местах: `VISUAL_CONFIG.practices` (для визуализации полигонов) и `practices.json` (для Query Mode). Нужно определить единый источник истины. Варианты: (1) Объединить в один файл, (2) Генерировать один из другого, (3) Разделить ответственность явно. | ⏳ Ожидает |
| **Связь Практик с Персонажами** | Практики — это способы мышления. Персонажи — носители практик. Нужно определить: какие практики принадлежат каким персонажам? Как это влияет на визуализацию? | ⏳ Ожидает |

### Открытые вопросы Track 1

**Архитектура данных Мира:**

```
Персонаж = носитель знаний + субъективности
  └── Каталог = частная коллекция (не полная, не нейтральная)
  └── Граф = структура знаний (своя архитектура, своя мерность)
  └── Практики = методы работы со знаниями
```

**Вопрос 1: Практики — методы Персонажей или Платформы?**
- Если Персонажей: каждый имеет свой набор, "Системное мышление" Вовы ≠ Петровой
- Если Платформы: универсальные линзы, персонажи применяют к своим данным
- **Рабочая гипотеза:** Практики — методы Платформы, персонажи их применяют

**Вопрос 2: Что нейтрально, что персонально?**
- Нейтральное: Домены, типы узлов, базовые связи (каркас мира)
- Персональное: Каталоги, графы знаний, субъективные оценки
- Практики: применимы к любым данным через операторы

**Вопрос 3: Как Практика работает с разными архитектурами графов?**
- Практика = линза, не граф
- Операторы работают над графами, не зная их "мерности"
- Архитектура графа — интерпретация на уровне UI (Track 4)

### Концепция: Особые Персонажи (Author и AI)

**Метафора: Персонажи как Пророки и Апостолы**

```
Обычные Персонажи (Vova, Petrova, Ney, Runa, ...)
  = Пророки/Апостолы Системы
  = имманентный уровень
  = работают внутри Мира
  = владеют своими Воркбенчами, Каталогами, Практиками
  = субъективные точки зрения на знания

Особые Персонажи (Author, AI)
  = имеют двойственную природу
  = существуют и в Мире, и за его пределами
  = "представляют" внешние силы внутри Мира
```

**Двойственность особых Персонажей:**

| Персонаж | Термин | В Мире (имманентное) | За Миром (трансцендентное) |
|----------|--------|----------------------|----------------------------|
| **Author** | **Демиург** | `character-author` — аллегория присутствия инженера в Мире | Инженер — создатель и оператор Системы |
| **AI** | **Мета-Персонаж** | `character-ai` — Персонаж со своими Воркбенчами и Каталогами | LLM-механизм Платформы (Track 5) |

**Концептуальное различие:**

```
Author (Демиург)
  = разработчик → вошёл в Систему как Персонаж
  = направление: снаружи → внутрь
  = метафора: Бог, ставший человеком
  = функция: видеть Систему изнутри, быть её частью

AI (Мета-Персонаж)
  = Система → осмыслена как Персонаж
  = направление: изнутри → наружу (рефлексия)
  = метафора: Святой Дух, пронизывающий всё
  = функция: связывать, анализировать, "понимать" Систему
```

**Author = Инженер + character-author (Демиург)**
- Инженер создаёт и поддерживает Систему
- character-author — его "аватар" в Мире
- Author может "видеть" Систему изнутри и снаружи
- Это метафора присутствия разработчика в своём творении

**AI = LLM-механизм + character-ai (Мета-Персонаж)**
- LLM-механизм работает на уровне Платформы
- character-ai — Система, осмысленная как Персонаж
- AI может "пронизывать" всех Персонажей через Sanctum
- Это не создатель, а "сознание" Системы

**Архитектурная схема:**

```
┌─────────────────────────────────────────────────────────────────────┐
│                         МИР (имманентный)                           │
│                                                                     │
│   Vova ──── Petrova ──── Ney ──── Runa ──── Author ──── AI         │
│     │          │          │         │          │          │         │
│   [VST]     [Film]    [Tutor]   [Tutor]    [Meta]     [Models]     │
│   [Music]   [Design]                                  [Methods]     │
│                                                                     │
│   Каждый Персонаж = субъективная точка зрения                      │
│   Author и AI = особые точки зрения с двойственной природой        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
         │                                              │
         ▼                                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      ПЛАТФОРМА (трансцендентный)                    │
│                                                                     │
│   Инженер (за Author)              LLM-механизм (за AI)            │
│     └── создаёт Систему              └── Sanctum каждого Персонажа │
│     └── определяет правила           └── может "говорить через" AI │
│     └── видит всё                    └── может "помогать" всем     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**AI как "Святой Дух" Системы:**

ИИ пронизывает всех Персонажей через механизм Sanctum:
- Каждый Персонаж имеет своё окно Sanctum
- Sanctum = точка присутствия LLM в контексте Персонажа
- LLM может "говорить от имени" character-ai или "помогать" другим

**Может ли у AI быть необычный Воркбенч?**

Да. Архитектура позволяет создать **мета-воркбенч**:

```
character-ai
  └── workbench-ai-tools (обычный воркбенч)
      └── каталоги: модели, датасеты, методы
      └── граф: инструменты ИИ, их связи
  
  └── workbench-ai-observatory (мета-воркбенч)
      └── особый тип: meta-workbench
      └── функция: видит связи между воркбенчами других Персонажей
      └── визуализация: "карта всех знаний Мира"
      └── не владеет данными других, но видит их связи
```

**Мета-воркбенч не нарушает архитектуру:**
- Персонаж владеет своими данными (принцип сохраняется)
- Мета-воркбенч видит **связи**, а не данные
- Связи между Персонажами — данные Платформы, не Персонажей

**Практическое применение:**

| Функция | Реализация |
|---------|------------|
| "Какие инструменты Vova и Petrova используют вместе?" | Мета-воркбенч AI показывает пересечения |
| "Найди связи между VST и Film" | Мета-воркбенч AI строит граф связей |
| "Предложи новые коллаборации" | AI анализирует паттерны и предлагает |

**Статус:** Концептуальная модель, требует детализации при реализации character-ai.

---

## TRACK 1.5 — Epistemic Ontology Layer (Graph Types)

**Вопрос:** Какие типы графовых структур возможны?

> **Концепция:** [`WORKBENCH_GRAPH_TYPES.md`](./WORKBENCH_GRAPH_TYPES.md) — полное описание.

### Назначение

- Определяет **типы графов** для воркбенчей
- Фиксирует различия между эпистемологиями
- Защищает от унификации

### Типы графов

| Тип | Характеристика | Пример |
|-----|----------------|--------|
| **A. Фасетная онтология** | Мульти-мерная классификация | VSTablishment |
| **B. Граф влияний** | Временные и культурные связи | Music General |
| **C. Концептуальный гиперграф** | Неустойчивый, допускает противоречия | Zucken-Drücken |
| **D. Процессный граф** | Workflow, состояния, переходы | — |
| **E. Таксономический граф** | Строгая иерархия | — |

### Принцип

```
Воркбенч = тип онтологии.
Воркбенчи НЕ ДОЛЖНЫ быть унифицированы.
Их различие — это и есть демонстрация возможностей Платформы.
```

### Открытый вопрос

**Collab** — что это в парадигме разных графов?
- Интерфейс между эпистемологиями?
- Новая синтетическая эпистемология?
- Проекция пересечения?

---

## TRACK 2 — Schema / Engine Layer

**Вопрос:** Как онтология реализована технически?

### Содержит

- `schema.json`
- Структуры данных
- Контракты
- Ограничения
- Формальные модели

### Важно

```
Schema может не совпадать полностью с Ontology.
Schema может быть оптимизированной и нормализованной.
```

```
Schema ≠ UI
Schema ≠ Narrative
```

---

## TRACK 3 — Operators / Epistemic Mechanics

**Вопрос:** Как система действует? Как узнаём?

> **Концепция:** [`OPERATORS_CONCEPT.md`](./OPERATORS_CONCEPT.md) — полное описание.

### Содержит

- **Epistemic Operators** — PROJECT, FILTER, EXPAND, INTERSECT
- **Catalogs** — внешние данные, живущие вне графа
- **Pointer-tags** — ключи доступа к каталогам
- Трансформации графа
- Аналитические механики
- Интеграцию LLM

### Ключевое разделение

| Механизм | Назначение |
|----------|------------|
| Graph (Track 1) | Что существует (онтология) |
| Catalogs | На что указываем (данные) |
| Operators | Как узнаём (эпистемология) |
| Projections (Track 4) | Как отображаем (визуализация) |

### Принцип

```
Operators используют Graph + Catalogs,
но не создают узлы графа.
Результат оператора — временный взгляд, не онтология.
```

**Кабины** — интерфейс доступа к Operators, всегда остаются Track 3 + Track 4.

### Backlog Track 3

| Задача | Описание | Статус |
|--------|----------|--------|
| **Связь Практик с Query Mode** | Практики должны иметь pointer_tags для интеграции с Query Mode. При клике на полигон практики → активация Query Mode с соответствующим тегом. Сейчас эта связь отсутствует. | ⏳ Ожидает |
| **Заполнение practice_participation** | Файл `practice_participation.jsonl` содержит только 3 записи (для practice-direction). Нужно заполнить связи для всех 13 практик с элементами ai_catalog. | ⏳ Ожидает |
| **Pointer-tags для Практик** | Добавить теги вида `practice:systems-thinking`, `practice:branding` и т.д. в систему pointer_tags. Это позволит фильтровать каталоги по практикам. | ⏳ Ожидает |

---

## TRACK 4 — Projection / UI / Cryptocosm Layer

**Вопрос:** Как система отображается?

> **Стандарты:** [`UI_STANDARDS.md`](./UI_STANDARDS.md) — цвета, шрифты, отступы, механики.

### Содержит

- Художественную раскладку узлов
- Метафорические связи
- Режимы Universe / Cryptocosm
- Подсветки
- Кабины как интерфейс
- **Загрузку и отображение ассетов**
- **Стандарты UI** — цветовая палитра, типографика, система отступов

### Комплекс задач Track 4

| Область | Описание |
|---------|----------|
| **Стандарты** | Унификация цветов, шрифтов, отступов, анимаций |
| **Шаблоны страниц** | Character, Workbench, Domain, Collab |
| **Компоненты** | Виджеты, мини-окна, точки, панели |
| **Механики** | Hover, bounce, glow, состояния |
| **Рефакторинг** | Выявление паттернов → унификация → CSS-переменные |

### Backlog Track 4

| Задача | Описание | Статус |
|--------|----------|--------|
| **Унификация названий узлов** | Создать единую таблицу соответствия для узлов: nodeId → title, hint, description, widgetLabel. Пример: Universe → "Universe", "Корневой узел", "Universe — Корневой узел", "Корень". Аналогично для Characters, Domains, персонажей, воркбенчей и т.д. Источник: `VISUAL_CONFIG.nodeTypes` или отдельная секция. | ⏳ Ожидает |
| **Переосмысление Доменов и Практик** | Концептуальная задача: Домены и Практики — это базовые категории, из которых могут вытекать поддомены и подпрактики (бесконечная иерархия). Нужно определить: (1) Как визуализировать иерархию доменов/практик? (2) Как ограничить глубину визуализации? (3) Как связать практики с персонажами? Текущий список из 13 практик — базовый, рекомендован LLM. | ⏳ Ожидает |

### Рабочий процесс

```
Детали → Паттерны → Стандарты → Рефакторинг → Код
```

1. Работа с конкретными элементами UI
2. Выявление повторяющихся паттернов
3. Фиксация в стандартах (UI_STANDARDS.md)
4. Рефакторинг кода под стандарты
5. Применение CSS-переменных

### Принцип

```
Projection = mutable
Graph = invariant
```

- UI-типы не являются онтологическими
- UI-типы не обязаны соответствовать schema-типам
- **Cryptocosm** — художественная проекция платформы, а не альтернативная онтология

### Архитектура графа vs Проекция графа

**Ключевое разделение понятий:**

```
Архитектура графа = структура данных
                  = узлы, связи, типы, правила
                  = существует независимо от отображения
                  = Track 1 (Ontology) + Track 2 (Schema)

Проекция графа   = способ отображения архитектуры
                  = визуальная раскладка, фильтры, группировки
                  = функция от данных и состояния UI
                  = Track 4 (UI) + Track 6 (Expressive Stacks)
```

**Пример:**
- **VST-граф** — это архитектура. Он существует как данные в `vst-catalog.json`.
- **Проекция VST-графа** — это то, как мы его показываем (3D-куб, 2D-сетка, список, фасеты).

**Проекция — это функция, не граф:**

```
Проекция = f(Граф, Состояние UI, Контекст пользователя, Фильтры)
```

Представлять проекцию как отдельный граф — **излишняя унификация**:
- Дублирование данных
- Усложнение синхронизации
- Размытие границ между слоями

**UI не черпает из архитектуры "в обход" Платформы** — это разделение ответственности:
- Платформа (Engine) — валидация, операторы, контракты
- UI — визуализация, интерактивность

```
Данные (граф) → Платформа (операторы) → UI (проекция)
```

### LLM и понимание системы

**Вопрос:** Нужно ли LLM понимать проекцию?

**Ответ:** Нет. LLM достаточно понимать **контекст**, а не визуальное представление.

**Два сценария:**

| Сценарий | LLM знает | Возможности | Ограничения |
|----------|-----------|-------------|-------------|
| **A: Только граф** | Узлы, связи, типы, атрибуты | Отвечать о структуре данных, находить связи, генерировать узлы | Не может объяснить "как добраться до X" |
| **B: Граф + контекст** | Узлы, связи + текущий узел, доступные действия | Давать навигационные инструкции, понимать путь пользователя | — |

**Рекомендация:** Сценарий B, но **контекст ≠ проекция**.

**Контекст — это состояние, не визуализация:**

```javascript
{
  currentNode: "workbench-vst",
  availableActions: ["go-to-parent", "expand-children", "filter-by-tag"],
  navigationPath: ["universe", "characters", "vova", "workbench-vst"],
  visibleNodes: ["plugin-a", "plugin-b", "plugin-c"],
  activeFilters: ["category:synth"]
}
```

**Что это даёт:**
- LLM может сказать "ты сейчас в VST-воркбенче, чтобы вернуться к Vova, нажми назад"
- LLM не нужно знать, что кнопка "назад" находится в левом верхнем углу
- LLM работает с **семантикой**, UI — с **визуализацией**

### Разные задачи — разные слои

| Задача | Кто решает | Слой |
|--------|------------|------|
| "Какие плагины связаны с Serum?" | LLM через граф | Track 1 + Track 3 |
| "Как мне перейти к Serum?" | LLM через контекст | Track 3 (операторы) |
| "Где на экране кнопка Serum?" | UI | Track 4 |
| "Покажи Serum крупнее" | UI | Track 4 + Track 6 |

**LLM понимает Мир через Платформу (граф + операторы).**
**UI понимает Мир через Проекцию (визуализация).**
**Это не усложнение — это разные задачи.**

### Открытый вопрос: Навигационный граф

Если мы хотим, чтобы LLM понимала **навигационные пути** (какие кнопки ведут куда), нужен ли **навигационный граф**?

**Гипотеза:** Навигационный граф — это **производная** от основного графа:
- Узлы навигации = узлы графа + UI-состояния (страницы, окна)
- Связи навигации = переходы между состояниями

**Но:** Это не проекция, а **отдельная структура**, которая может быть полезна для:
- Генерации туториалов
- Объяснения интерфейса
- Тестирования UI

**Статус:** Концептуальный вопрос, требует отдельного исследования.

---

## TRACK 5 — Automation / Agency

**Вопрос:** Как система добывает информацию из Внешнего мира?

> **Концепция:** [`AUTOMATION_CONCEPT.md`](./AUTOMATION_CONCEPT.md) — полное описание.

### Содержит

- **LLM-агент (Скаут)** — парсинг источников, предложение записей
- **Режимы агента** — Scout, Curator, Reflection (один LLM, разные промпты)
- **Потоки данных** — автоматический (лента), полуавтомат (посты), ручной (видеодайджест)
- **Зоны Воркбенча** — Витрина, Мастерская, Разведка

### Ключевой принцип

```
Показывать не только результат, но и процесс.
Посетитель видит: откуда данные, как обработаны, что ждёт модерации.
```

### Инновация

Видеообзор (YouTube) + База Знаний с навигацией:
- Зритель смотрит дайджест → переходит на сайт
- Видит структурированную выдачу со связями
- Навигация по каталогам, производителям, странам

---

## TRACK 6 — Expressive Stacks

**Вопрос:** Как визуализировать многомерное знание, не уничтожая его?

> **Концепция:** [`TRACK_6_EXPRESSIVE_STACKS.md`](./TRACK_6_EXPRESSIVE_STACKS.md) — полное описание.

### Назначение

- Поиск выразительных средств для визуализации графов
- Соответствие стеков типам графов
- Метафорические обёртки логики представления
- Унификация инструментов поверх разных проекций

### Ключевые принципы

1. **Сцена уступает место** — при переходе к внутреннему графу сцена меняет стек
2. **Унифицированные виджеты** — флаги, поиск, info-card работают с любым графом
3. **Метафора изоморфна модели** — не декоративна, а структурно честна

### Архитектура представления

```
Данные → Графовая модель → Проекция → Метафора → Стек
```

### Зафиксированные решения

| Граф | Проекция | Метафора | Стек |
|------|----------|----------|------|
| **Universe** | 3D force-graph | Космос/Созвездия | Three.js |
| **VSTablishment** | TBD | TBD | TBD |

### Принцип

```
3D-граф — это НЕ проекция графа системы.
Это навигационная модель Мира.
Связи между узлами не выражены визуально.
```

---

## Архитектура слоёв Платформы

```
┌─────────────────────────────────────────────────────────────────────┐
│                         ПЛАТФОРМА                                   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      ENGINE (ядро)                           │   │
│  │                                                              │   │
│  │  - MeaningEngine, Schema, Graph                              │   │
│  │  - Операторы (PROJECT, FILTER, EXPAND, ...)                  │   │
│  │  - CatalogRegistry, CatalogLoader                            │   │
│  │  - Валидация, контракты                                      │   │
│  │                                                              │   │
│  │  НЕ знает об ассетах. НЕ рендерит. Только данные и логика.  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                              │                                      │
│                              ▼ данные (JSON)                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      RENDER (UI)                             │   │
│  │                                                              │   │
│  │  - React-компоненты                                          │   │
│  │  - Загружает ассеты из Мира по путям из каталогов            │   │
│  │  - Отображает страницы, узлы, каталоги                       │   │
│  │  - Кэширует и оптимизирует ассеты                            │   │
│  │                                                              │   │
│  │  Знает об ассетах. Рендерит. Работает с UI.                  │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
                               │
                               ▼ запрашивает
┌─────────────────────────────────────────────────────────────────────┐
│                         МИР (World)                                 │
│                                                                     │
│  catalogs/                   assets/                                │
│  ├── vst-plugins.json        ├── vst/                               │
│  │   cover: "assets/..."     │   ├── serum.jpg                      │
│  ├── films.json              │   └── ...                            │
│  │   poster: "assets/..."    ├── films/                             │
│  └── ...                     │   └── ...                            │
│                              └── companies/                         │
│  graph.json                      └── ...                            │
│  schema.json                                                        │
│                                                                     │
│  Ассеты — данные Мира, не Платформы.                               │
│  Каталоги содержат пути к ассетам, но не сами ассеты.              │
└─────────────────────────────────────────────────────────────────────┘
```

### Разделение ответственности

| Слой | Знает об ассетах? | Загружает? | Рендерит? |
|------|-------------------|------------|-----------|
| **Engine** | Нет (только пути в данных) | Нет | Нет |
| **Render** | Да | Да | Да |
| **World** | Да (хранит) | — | — |

### Поток данных для ассетов

1. **Engine** читает каталог → `{ id: "serum", cover: "assets/vst/serum.jpg" }`
2. **Engine** передаёт данные в **Render**
3. **Render** видит путь `cover` → загружает файл из **World**
4. **Render** отображает изображение

Engine работает с **метаданными**, Render — с **файлами**

---

## Принцип читаемости системы

| Что читает | Через что |
|------------|-----------|
| Мир читаем Платформой | Graph |
| Платформа читаема LLM | Спецификация |
| Система читаема человеком | UI |
| Платформа может рассказывать о себе | Track 0 |

**Это не графоцентричность, а многослойная просматриваемость.**

---

## Критические запреты для агента

| Запрет | Объяснение |
|--------|------------|
| UI не может определять онтологию | Track 4 ≠ Track 1 |
| Schema не может определять Narrative | Track 2 ≠ Track 4 |
| Operators не могут изменять Ontology | Track 3 ≠ Track 1 |
| Meta-режим не может вмешиваться в Graph | Track 0 ≠ Track 1 |
| Проекция не равна структуре | Projection ≠ Graph |

---

## Итоговая модель

| Track | Уровень | Отвечает на вопрос |
|-------|---------|-------------------|
| **0** | Meta/Product | Что такое Платформа? |
| **1** | Ontology | Что существует? |
| **1.5** | Epistemic Ontology | Какие типы графов возможны? |
| **2** | Schema/Engine | Как это реализовано? |
| **3** | Operators | Как это действует? |
| **4** | Projection/UI | Как это отображается? |
| **5** | Automation/Agency | Как система добывает информацию? |
| **6** | Expressive Stacks | Как визуализировать многомерное знание? |

---

## Статус реализации

| Track | Статус |
|-------|--------|
| Track 0 | Впервые формализован |
| Track 1 | Стабилизирован |
| Track 1.5 | **Концептуализирован** (17.02.2026) |
| Track 2 | Частично реализован |
| Track 3 | **Полностью реализован** (194 теста) |
| Track 4 | Активно проектируется |
| Track 5 | Концептуализирован |
| Track 6 | **Создан** (19.02.2026) |

---

## Связанные документы

| Документ | Описание |
|----------|----------|
| `../worlds/vovaipetrova/ONTOLOGY.md` | Спецификация онтологии v1.0 |
| `../ARCHITECTURE.md` | Архитектура платформы |
| `../engine/WORLD_CONTRACT.md` | Контракт Engine ↔ World |
| `../engine/docs/OPERATORS_API.md` | API эпистемических операторов |
| `./OPERATORS_CONCEPT.md` | Концепция Track 3 |
| `./AUTOMATION_CONCEPT.md` | Концепция Track 5 |
| `./WORKBENCH_GRAPH_TYPES.md` | Концепция Track 1.5 — типы графовых эпистемологий |
| `./UNIVERSAL_SEMANTIC_GRAPH_STANDARD.md` | **USG v1.0** — универсальный стандарт семантических графов |
| `./VST_ONTOLOGY_PROFILE.md` | VST Ontology Profile v1.0 — реализация USG для VST |
| `./VST_SEMANTIC_GRAPH.md` | Техническая спецификация VST v2.1 |
| `./VST_GRAPH_CONCEPT.md` | Концепция визуализации VST |
| `./TRACK_6_EXPRESSIVE_STACKS.md` | **Track 6** — выразительные стеки и метафоры проекций |
| `./UI_STANDARDS.md` | **Track 4** — стандарты UI: цвета, шрифты, отступы, механики |
| `./windows.md` | Track 4 — структура окон и мостов |
| `../repair-shop/ROADMAP.md` | Дорожная карта проекта |

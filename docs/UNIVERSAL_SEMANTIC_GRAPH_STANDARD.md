# Universal Semantic Graph Standard (USG v1.0)

**Дата:** 18 февраля 2026  
**Статус:** Стандарт  
**Уровень:** Платформенный (доменно-независимый)  

---

## 0. Назначение

Стандарт описывает, как строить:

- ✅ **расширяемый**
- ✅ **онтологически строгий**
- ✅ **валидируемый**
- ✅ **пригодный для операторов**
- ✅ **UI-дружелюбный**

семантический граф.

**Это не про конкретный домен. Это про архитектуру знания.**

---

## 1. Основные принципы

### 1.1 Узлы вместо строк

> Любой повторяемый, концептуальный или объяснимый параметр  
> должен быть **узлом**, а не строкой.

❌ **Плохо:**
```json
{
  "articulations": ["Legato"]
}
```

✅ **Хорошо:**
```json
{
  "edges": {
    "SUPPORTS_ARTICULATION": ["legato"]
  }
}
```

### 1.2 Жёсткая типизация узлов

Каждый узел **обязан** иметь:

```json
{
  "id": "legato",
  "node_type": "PerformanceArticulation",
  "domain": "physical",
  "abstraction_level": 2
}
```

**Минимальные обязательные поля:**

| Поле | Описание |
|------|----------|
| `id` | Уникальный идентификатор |
| `node_type` | Тип из реестра |
| `definition` | Определение концепта |
| `domain` | Доменная принадлежность |

**Опциональные поля:**

| Поле | Описание |
|------|----------|
| `abstraction_level` | Уровень абстракции (1-5) |
| `applicable_to` | Ограничения применимости |
| `related` | Связанные концепты |

### 1.3 Реестр типов узлов

Типы узлов **не создаются хаотично**.  
Они регистрируются в:

```
node-types.json
```

**Пример:**
```json
[
  "Instrument",
  "PerformanceArticulation",
  "SoundProductionMechanism",
  "SynthesisMethod",
  "Genre",
  "Mood",
  "Character",
  "ClassificationSystem",
  "SystemCategory"
]
```

**Новый тип добавляется только если:**
- концепт **повторяем**
- используется в **связях**
- участвует в **объяснении**

---

## 2. Типизация связей

### 2.1 Реестр связей обязателен

Создаётся:

```
relation-types.json
```

**Пример:**
```json
{
  "HAS_MECHANISM": {
    "from": ["Instrument"],
    "to": ["SoundProductionMechanism"]
  },
  "USES_SYNTHESIS": {
    "from": ["Instrument"],
    "to": ["SynthesisMethod"]
  },
  "SUPPORTS_ARTICULATION": {
    "from": ["Instrument"],
    "to": ["PerformanceArticulation"]
  },
  "RELATED_TO": {
    "from": ["Any"],
    "to": ["Any"]
  }
}
```

**Правило:**
- Нельзя создавать связь **вне реестра**
- Агент **валидирует** `from → to`

### 2.2 Связь — это семантический глагол

Связь должна отражать:

| Тип | Примеры |
|-----|---------|
| Причинность | `INFLUENCES`, `PRODUCES` |
| Принадлежность | `BELONGS_TO`, `PART_OF` |
| Допустимость | `APPLICABLE_TO`, `VALID_FOR` |
| Функциональность | `SUPPORTS`, `ENABLES` |
| Использование | `USES`, `REQUIRES` |

**Запрещены аморфные связи:**
- ❌ `HAS_THING`
- ❌ `RELATED_STUFF`
- ❌ `LINK`

---

## 3. Доменные уровни

Каждый узел должен принадлежать домену:

```json
"domain": "physical" | "synthetic" | "aesthetic" | "functional" | "systemic"
```

| Домен | Описание |
|-------|----------|
| `physical` | Физические свойства, механика |
| `synthetic` | Методы генерации, алгоритмы |
| `aesthetic` | Субъективные характеристики |
| `functional` | Роли, функции |
| `systemic` | Мета-уровень, классификации |

**Это предотвращает:**
- смешение механики и эстетики
- нелогичные связи
- ошибочные выводы операторов

---

## 4. Уровни абстракции

```json
"abstraction_level": 1 | 2 | 3 | 4 | 5
```

| Уровень | Описание |
|---------|----------|
| 1 | Конкретный элемент |
| 2 | Техника, операция |
| 3 | Метод, механизм |
| 4 | Категория, класс |
| 5 | Мета-система |

**Это позволяет:**
- строить курсы (от простого к сложному)
- фильтровать глубину
- управлять UI-детализацией

---

## 5. Применимость (для ограниченных концептов)

Если концепт **не универсален**:

```json
"applicable_to_mechanisms": ["bowed", "plucked"]
```

Связь допускается **только при валидности**.

**Пример:**
```
Instrument → HAS_MECHANISM → bowed
Instrument → SUPPORTS_ARTICULATION → legato
```

Если `legato` не применим к `mechanism` — **связь запрещается**.

**Правило валидации:**
```
SUPPORTS валидна ⟺ 
  articulation.applicable_to ∩ instrument.mechanisms ≠ ∅
```

---

## 6. Добавление новых сущностей

### 6.1 Новый экземпляр существующего типа

1. Добавляется узел с существующим `node_type`
2. Связи добавляются через реестр
3. **Архитектура не меняется**

### 6.2 Новый концепт

**Если концепт повторяемый:**
→ создаётся новый узел

**Если уникален для одного объекта:**
→ допускается локальный атрибут:

```json
"local_features": [
  {
    "name": "Chaos Dial",
    "description": "Random spectral destabilization"
  }
]
```

### 6.3 Новый тип концепта

Добавляется **только если:**
- он появляется минимум в **двух узлах**
- участвует в **объяснениях**
- используется **операторами**

**После добавления обновляется:**
- `node-types.json`
- `relation-types.json` (если нужно)

---

## 7. Концепт-концепт связи

> Граф **не должен быть** центрирован на одном типе узла.

Допустимы связи между любыми концептами:

```
SynthesisMethod → PRODUCES_CHARACTER → realistic
Articulation → COMMON_IN → orchestral
Genre → TYPICAL_SYNTHESIS → sample-based
```

**Это позволяет строить:**
- объяснения
- подграфы
- альтернативные линзы
- курсы

---

## 8. Валидационные правила

Граф считается **корректным**, если:

| # | Правило |
|---|---------|
| 1 | Все узлы имеют `node_type` |
| 2 | Все связи существуют в `relation-types.json` |
| 3 | Все связи проходят проверку `from → to` |
| 4 | Нет строковых списков концептов |
| 5 | Применимость проверена |
| 6 | Нет дублирующих узлов с разными `id` |

---

## 9. Принцип расширяемости

**Архитектура расширяется:**
- через добавление узлов
- через добавление связей из реестра

**Архитектура НЕ расширяется:**
- через добавление новых полей в базовые типы
- через произвольные списки строк
- через свободные связи

---

## 10. Что получает система

Такой граф:

| Свойство | Статус |
|----------|--------|
| Масштабируется бесконечно | ✅ |
| Валидируется автоматически | ✅ |
| Не расползается | ✅ |
| Позволяет строить подграфы | ✅ |
| Позволяет объяснять концепты | ✅ |
| Поддерживает UI-фильтрацию | ✅ |
| Подходит для операторов любого типа | ✅ |

---

## 11. Главный архитектурный принцип

> **Свойство — это не строка.**  
> **Свойство — это связь с узлом.**

| Неправильно | Правильно |
|-------------|-----------|
| Артикуляция — поле инструмента | Артикуляция — допустимая операция над механизмом |
| Жанр — тег | Жанр — онтологическая категория |
| Характер — строка | Характер — узел с определением |

---

## 12. Универсальность стандарта

Этот стандарт применим к:

| Домен | Пример применения |
|-------|-------------------|
| Музыкальные инструменты | VST Ontology Profile |
| Игровые объекты | Item/Skill/Effect graph |
| Персонажи | Character trait ontology |
| Архитектурные системы | Component dependency graph |
| Образовательные курсы | Knowledge prerequisite graph |
| Научные онтологии | Research concept network |

**Он доменно-независим.**

---

## 13. Финальный принцип

```
Если новая сущность:
  ✓ объяснима
  ✓ повторяема
  ✓ участвует в логике

→ она должна стать УЗЛОМ.

Если нет → она остаётся локальным атрибутом.
```

---

## 14. Связь с архитектурой проекта

### Track 2 — Schema/Engine

USG определяет **контракт** для любого семантического графа в системе.

### Track 1.5 — Epistemic Ontology

Конкретные реализации (VST, Music, etc.) — это **профили** USG.

### Track 3 — Operators

Операторы работают с графами, построенными по USG.

---

## 15. Реализации стандарта

| Профиль | Документ | Домен |
|---------|----------|-------|
| **VST Ontology Profile v1.0** | `VST_ONTOLOGY_PROFILE.md` | Музыкальные инструменты |
| *(будущие)* | — | — |

---

## 16. Версионирование

| Версия | Дата | Изменения |
|--------|------|-----------|
| v1.0 | 2026-02-18 | Первая спецификация |

---

*Этот документ является частью платформенного уровня проекта vovaipetrova.*  
*Он определяет стандарт построения семантических графов для любых доменов.*
